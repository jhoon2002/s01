# Routing

* ROOT
         
      src/routes   *project config 에서 변경 가능
   
* 라우트 파일
  
      '+' prefix
  
* +page.svelte
      
      앱의 페이지를 정의하는 컴포넌트, SSR, CSR 모두에서 렌더링 가능
        
* +page.js(ts)
    
      렌더링되기 전에 일부 데이터를 로드하기 위해 load 함수를 내보냄
  
      +page.svelte 와 함께 실행 => 그 의미는, page.svelte 가 SSR 중엔 서버에서 CSR 중엔 브라우저에서 실행
     
      내보내는 것들 > load, prerender, ssr, csr
    
* +page.server.js
    
      로드 기능이 서버에서만 실행해야 하는 경우
      (예: 데이터베이스에서 데이터를 가져와야 하거나 API 키와 같은 개인 환경 변수에 액세스해야 하는 경우)
      내보내는 것들
       1. load: 서버에서 데이터를 읽음
       2. actions: <form> 요소로 서버에 데이터 저장
       3. page options: prerender, ssr, csr

* +error

      로드 중에 오류가 발생하면 경로별 기본 오류 페이지(+error.svelte)를 렌더링
      해당 경로에 에러 파일이 없을 경우 경로를 따라 올라감 src/routes/+error.svelte 까지
      이것도 없을 시, src/error.html
      No route 시, 404 에러
      +error.svelte는 handle 또는 +server.js 의 request hander 내에서 오류가 발생할 때는 미사용
  
* +layout.svelte: default layout

      nested layout 가능 /src/routes/+layout.svelte, /src/routes/setting/+layout.svelte
  
* +layout.js

      내보내는 것들(load, prerender, ssr, csr)
  
      load: 가져온 값은 하위 페이지에서 이용 가능(export let data), 하위 페이지 탐색시 데이터 변경 X
      prerender, ssr, csr: 하위 페이지의 디폴드가 됨
  
* +layout.server.js

      서버에서 실행, 내보내는 것들 prerender, ssr, csr 동일

* +server(= api route = endpoint): 페이지뿐만 아니라 응답을 완전히 제어하는 방식으로 경로 정의할 수 있음
  
      ex) /api/random-number 즉, 이것도 route(경로) 범주에서 이해하는 것이 옳다.
  
* +server.js(ts)
  
      내보내는 것들(GET, POST, PATCH, PUT, DELETE) => 인자(RequestEvent), 반환(Response)
      (참고)@sveltejs/kit 의 error, redirect, json methods 이용 가능
  
* +server.js 와 +page 가 같은 위치인 경우 처리 규칙
       
      PUT/PATCH/DELETE: 항상 +server.js 로 핸들링
      GET/POST: 헤더가 text/html 이면 +page 로 핸들링, 아니면 +server.js 로 핸들링
  
* $types: svelteKit 이 hidden 디렉토리에 생성하는 type 파일
    
      PageLoad, PageServerLoad, LayoutLoad or LayoutServerLoad
  
* 그외 다른 파일: 경로 디렉터리 내의 다른 모든 파일은 SvelteKit 에서 무시됨.

      이는 구성 요소와 유틸리티 모듈을 필요한 경로와 함께 배치할 수 있음을 의미.
      여러 경로에서 구성 요소와 모듈이 필요한 경우 $lib에 두는 것이 좋음.

# Loading data

* Page data
 
       load 함수 return(+page.js +page.server.js) => export let data (+page.svelte 의 prop)
 
* Layout data

* +layout.js 또는 +layout.server.js => +layout.svelte
  
        child +layout.svelte components 와 +page.svelte component 에서도 export let data 로 받을 수 있음
        (참고) 여러개 load 함수 -> 마지막 것이 반영
 
* $page.data
  
      +page.svelte 와 그 위에 있는 +layout.svelte 가 갖는 자신 페이지 와 부모 페이지의 정보
      반대로 +layout.svelte 는 자신에 속한(즉, 자식인) +page.js 또는 +page.server.js 페이지 정보(예를 들어 타이틀)도 포함
       ex) $page.data.title
 
* Universal vs server

   * +page.js, +layout.js: export universal load 함수
   
   * +page.server.js, +layout.server.js: export server load 함수(only server-side)
  
         * (공통점) 양쪽 load 함수 모두 request 를 설명하는 프로퍼티(params, route, url)와 다양한 함수
           (fetch, setHeaders, parent, depends)에 접근 가능
         * (Server load) ServerLoadEvent 와 함께 호출되며, RequestEvent 로부터 clientAddress, cookies, locals, platform, request 를 상속함
         * (Universal load) LoadEvent 와 함께 호출되며, data 프로퍼티를 가짐
         * (참고) +page.js 와 +page.server.js (또는 +layout.js 와 +layout.server.js) 모두에
           load 함수가 있다면, 'Server load 함수'의 리턴 값은 'Universal load 함수' 인수의 data 프로퍼티임
         * (OUTPUT) 'Universal load 함수': 어떤 값을 가진 Object, custom class 나 컴포넌트 생성자 등
         * 'Server load 함수': 반드시 devalue 로 직렬화 가능한 data(JSON 으로 표현 가능한, BigInt, Date, Map, Set, RegExp 등)
         * (언제사용?) 'Server load 함수': 서버 로드 기능은 데이터베이스나 파일 시스템에서
             직접 데이터에 액세스해야 하거나 개인 환경 변수를 사용해야 할 때 편리

   * 'Universal load 함수': 외부 API에서 데이터를 가져와야 하고 개인 자격 증명이
        필요하지 않은 경우에 유용. SvelteKit은 서버를 통하지 않고 API에서 직접 데이터를
        가져올 수 있기 때문. Svelte 구성 요소 생성자와 같이 직렬화할 수 없는 항목을
        반환해야 하는 경우에도 유용.
   
   * 드물게 두 가지를 함께 사용해야 하는 경우: 예를 들어 서버의 데이터로 초기화된
     사용자 지정 클래스의 인스턴스를 반환해야 할 때

* Using URL data

      Load 함수는 종종 URL 에 의존: 이를 위해 load 함수가 제공하는 것
      1. url(origin, hostname, pathname, searchParams: URLSearchParams 오브젝): url.hash 는 load 중 접근 불가
      2. route: 현재 라우트 디렉토리(src/routes 로부터 상대 디렉토리)
      3. params: 예) route.id: '/a/[b]/[...c]' 에서 url.pathname: '/a/x/y/z' 인 경우,
       {
         "b": "x",
         "c": "y/z"
       }

* Making fetch requests

      external API, +server.js 로부터 데이터를 가져오기 위해
      +page.js 에서 fetch(native fetch web API 와 똑같이 작동하는) 사용 가능

* Cookies and headers

      'Server load 함수'는 쿠키를 인수로 받아 get, set 할 수 있음
      쿠키를 설정할 때 경로 속성에 유의, 예를 들어 admin/user 페이지에서 쿠키를 설정하면
      쿠키는 기본적으로 admin 페이지 내에서만 사용할 수 있음. 앱 전체에서 사용하려면 '/'로 설정
      'Server load 함수', 'Universal load 함수' 모두 setHeaders 함수 접근 가능 => 페이지 캐시에 유리

* Using parent data

      종종 load function 이 부모 load 함수에 접근할 필요. 이건 await parent() 로 가능

* Errors

      Load 에서 에러는 던지면 가장 가까운 +error.svelte 가 렌더링 됨
      @sveltejs/kit 의 error 헬퍼는 HTTP status 코드와 선택적 메세지를 담고 있음
      예상치 못한 에러가 던져지면, 스벨트 키트는 handleError 를 호출하고 500 에러로 다룸

* Redirects
      
      사용자를 리디렉션하려면 @sveltejs/kit의 리디렉션 도우미를 사용하여 3xx 상태 코드와 함께
      리디렉션되어야 하는 위치를 지정 예)throw redirect(307, '/login');

* Promise unwrapping

      폭포수를 생성하지 않고 여러 Promise를 쉽게 반환할 수 있는 최상위 Promise가 대기됩니다.
 
      export function load() {
        return {
          a: Promise.resolve('a'),
          b: Promise.resolve('b'),
          c: {
            value: Promise.resolve('c')
          }
        };
      }

* Parallel loading

       페이지를 렌더링(또는 탐색)할 때 SvelteKit은 모든 로드 기능을 동시에 실행하여 요청 폭포를
       방지합니다. 클라이언트측 탐색 중에 여러 서버 로드 함수를 호출한 결과는 단일 응답으로
       그룹화됩니다. 모든 로드 기능이 반환되면 페이지가 렌더링됩니다.

* Invalidation
 
      * SvelteKit은 탐색 중에 불필요하게 다시 실행하지 않도록 각 로드 함수의 종속성을 추적합니다.
      예를 들면, params.slug가 변경되었기 때문에 /blog/trying-the-raw-meat-diet에서
      /blog/i-regret-my-choices로 이동하면 +page.server.js에 있는 항목이 다시 실행됩니다.
      데이터가 여전히 유효하기 때문에 +layout.server.js에 있는 데이터는 그렇지 않습니다.
      
      * 즉, db.getPostSummaries()를 두 번 호출하지 않습니다.
      부모 로드 함수가 다시 실행되면 await parent()를 호출하는 로드 함수도 다시 실행됩니다.
      (수동 무효화) 또한 url에 종속된 모든 로드 함수를 다시 실행하는 invalidate(url) 및
      모든 로드 함수를 다시 실행하는 invalidateAll()을 사용하여 현재 페이지에 적용되는
      로드 함수를 다시 실행할 수 있습니다. 로드 함수는 fetch(url) 또는 depends(url)를
      호출하는 경우 url에 의존합니다. url은 [a-z]:로 시작하는 사용자 지정 식별자일 수 있습니다.

* Shared state

      많은 서버 환경에서 앱의 단일 인스턴스가 여러 사용자에게 서비스를 제공합니다.
      따라서 요청별 또는 사용자별 상태는 로드 함수 외부의 공유 변수에 저장하면 안 되며
      대신 event.locals에 저장해야 합니다.